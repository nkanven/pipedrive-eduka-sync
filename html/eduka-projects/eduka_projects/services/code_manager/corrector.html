<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>eduka-projects.eduka_projects.services.code_manager.corrector API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>eduka-projects.eduka_projects.services.code_manager.corrector</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import datetime
import random
import time
import webbrowser

import mysql.connector

from eduka_projects.services.code_manager import *

from eduka_projects.bootstrap import platform
from eduka_projects.utils.mail import EnkoMail
from eduka_projects.utils.rialization import serialize, deserialize
from eduka_projects.utils.eduka_exceptions import EdukaNoJobExecution
from eduka_projects.services.code_manager import CodeManager
from eduka_projects.services.code_manager.db_populate import Populate

from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import ElementNotInteractableException, ElementClickInterceptedException

from mysql.connector import errors
from dotenv import load_dotenv

load_dotenv()


class Correct(CodeManager):
    def __init__(self, school: str):
        &#34;&#34;&#34;
        The correct class browse Enko Dashboard in other to correct wrong student and family IDs
        &#34;&#34;&#34;
        super().__init__()
        self.browser = None
        self.school = school
        self.param = self.parameters
        self.cluster = &#34;&#34;
        self.mailer = EnkoMail(self.service_name, school)
        self.db_init()
        self.abbr = self.get_school_parameter(self.school, &#34;abbr&#34;)
        self.base_url = self.get_school_parameter(self.school, &#39;base_url&#39;)
        self.wrong_student_list_uri = self.base_url + self.get_school_parameter(self.school, &#39;wrong_student_list_uri&#39;)
        self.wrong_family_list_uri = self.base_url + self.get_school_parameter(self.school, &#39;wrong_family_list_uri&#39;)
        self.id_fname = &#34;idreplaced&#34; + self.abbr + &#34;.ep&#34;
        self.id_fname_path = os.path.join(self.autobackup_memoize, self.id_fname)

        self.columns_data: list = []
        self._old_code: list = []
        self.families = {}
        self.clean_datas = {}

        self.stats = {
            &#34;nber_student_wco&#34;: 0,
            &#34;nber_student_wco_rpl&#34;: 0,
            &#34;nber_family_wco&#34;: 0,
            &#34;nber_family_wco_rpl&#34;: 0,
            &#34;nber_guardian_wco&#34;: 0,
            &#34;nber_guardian_wco_rpl&#34;: 0
        }
        self.notifications = {
            &#34;errors&#34;: {
                &#34;students_blank_code&#34;: [],
                &#34;no_gender_students&#34;: [],
                &#34;no_clean_code_found&#34;: [],
                &#34;families_blank_code&#34;: []
            }
        }

        self.code_blocks = {&#34;person&#34;: None, &#34;user&#34;: None}

        self.no_code_available = []

        # Check Database components
        try:
            Populate(self.school).pre_check()
        except Exception:
            pass

    def code_is_empty(self, data: list, c_line, group=&#34;st&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Check if code is empty
        @param data: list of student or family data
        @param c_line: family line number
        @param group: default is st for student.
        @return: a boolean value
        &#34;&#34;&#34;
        result = False
        strip_data = str(data[0]).strip(&#34; &#34;)

        if strip_data == &#34;&#34;:
            if group == &#34;st&#34;:
                # Student&#39;s code is blank
                self.notifications[&#34;errors&#34;][&#34;students_blank_code&#34;].append(
                    (self.base_url, data[2], data[-1], self.cluster)
                )
            else:
                if strip_data == &#34;&#34;:
                    self.notifications[&#34;errors&#34;][&#34;families_blank_code&#34;].append(
                        (self.wrong_family_list_uri, c_line, self.cluster)
                    )
            result = True

        return result

    def get_wrong_ids(self):

        urls = [
            self.wrong_student_list_uri,
            self.wrong_family_list_uri
        ]

        for url in urls:
            if url == &#34;&#34;:
                continue

            # Close the browser after the first id collection in other to avoid an isolated browser left running
            try:
                self.browser.quit()
            except AttributeError:
                pass

            self.browser = platform.login(
                url=url,
                logins=self.logins(self.school)
            )

            # Get printable link list as it content full data
            platform.goto_printable(self.browser)

            self.columns_data = platform.get_printable(self.browser)

        if self.columns_data.__len__() == 0:
            raise EdukaNoJobExecution(self.service_name, self.school, &#34;No Id to correct found&#34;)

        random.shuffle(self.columns_data)

        self.browser.get(
            self.base_url
            + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]
        )

    def db_manipulations(self, old_code, c_platform, category, acad_year):
        # Get the oldest student id
        query = f&#34;select code_id, code from bank_code where platform=&#39;{c_platform}&#39; and cluster=&#39;{self.cluster}&#39; and acad_year=&#39;{acad_year}&#39; and category=&#39;{category}&#39; and is_used=0 order by code_id asc&#34;

        with mysql.connector.connect(**self.db_config) as conn:
            global res
            cursor = conn.cursor(buffered=True)
            cursor.execute(&#39;use enko_db&#39;)
            cursor.execute(query)
            res = cursor.fetchone()

        if res is not None:
            clean_code_id = res[0]
            clean_code = res[1]

            # Update bank_code and replacement_logs tables
            # To insecure consistency, query is wrapped inside a transaction

            query2 = f&#34;INSERT INTO replacement_logs (old_code, new_code) VALUES (%s, %s);&#34;
            query3 = f&#34;UPDATE bank_code SET is_used=1,update_date=NOW() WHERE code=%s;&#34;

            with mysql.connector.connect(**self.db_config) as conn:
                try:
                    conn.autocommit = False
                    cursor = conn.cursor()
                    cursor.execute(&#39;use enko_db&#39;)
                    cursor.execute(query2, (old_code, clean_code_id))
                    cursor.execute(query3, (clean_code,))

                    try:
                        clean_datas = self.families[old_code]
                    except Exception:
                        clean_datas = old_code

                    # Handle replacement here. Make sure all went well before storing
                    if self.code_replacer(clean_datas, clean_code):
                        conn.commit()
                    else:
                        conn.rollback()
                        exit(&#34;Stop execution&#34;)

                    # print(f&#34;{clean_code_id} for {clean_code} Update&#34;)
                except (errors.InternalError, errors.ProgrammingError, errors.IntegrityError,
                        errors.InterfaceError):
                    self.error_logger.critical(&#34;DB error occurred&#34;, exc_info=True)
                    conn.rollback()
                except Exception as e:
                    conn.rollback()
                    self.error_logger.critical(&#34;Exception occurred&#34;, exc_info=True)
                    print(&#34;Exception&#34;, str(e))

        else:
            self.notifications[&#34;errors&#34;][&#34;no_clean_code_found&#34;].append(
                (c_platform, acad_year, category, self.cluster)
            )

        corrector_memoize = {
            &#34;code&#34;: self._old_code,
            &#34;stats&#34;: self.stats,
            &#34;notif&#34;: self.notifications
        }
        serialize(self.id_fname_path, corrector_memoize)

    def code_categorizer(self):
        school_caracteristics = &#34;&#34;
        category_map = {&#34;male&#34;: &#34;mst&#34;, &#34;female&#34;: &#34;fst&#34;, &#34;family&#34;: &#34;fam&#34;}
        data_inputs = self.get_good_codes_from_excel(self.parameters[&#34;global&#34;][&#34;eduka_code_manager_data_inputs&#34;])

        for data_input in data_inputs:
            if self.base_url == data_input[0] + &#34;/&#34;:
                school_caracteristics = data_input
                break

        if school_caracteristics == &#34;&#34;:
            # TODO: Handle this failure
            print(&#34;Couldn&#39;t find the school. Exit the program&#34;)

        self.browser.get(

            self.base_url
            + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]

        )
        platform.get_tabs(&#34;tabs&#34;, self.browser).find_elements(By.TAG_NAME, &#39;li&#39;)[4].click()

        data_line_count = 0

        user_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
            EC.presence_of_element_located((By.ID, &#39;UserCodeBox&#39;)))

        person_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
            EC.presence_of_element_located((By.ID, &#39;PersonCodeBox&#39;)))

        self.code_blocks[&#34;person&#34;] = person_code_box
        self.code_blocks[&#34;user&#34;] = user_code_box

        if os.path.exists(self.id_fname_path):
            deserial = deserialize(self.autobackup_memoize, self.id_fname)[0]
            self._old_code = [] if deserial[&#34;code&#34;] is None else deserial[&#34;code&#34;]
            self.stats[&#34;nber_family_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco&#34;]
            self.stats[&#34;nber_guardian_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco&#34;]
            self.stats[&#34;nber_student_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco&#34;]
            self.stats[&#34;nber_student_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco_rpl&#34;]
            self.stats[&#34;nber_family_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco_rpl&#34;]
            self.stats[&#34;nber_guardian_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco_rpl&#34;]
            self.notifications = deserial[&#34;notif&#34;]

        for data in self.columns_data[:1]:
            print(f&#34;Correct {data}...&#34;)

            data_line_count += 1
            if len(data) &gt; 4:
                # Handle family data
                if self.code_is_empty(data, data_line_count, &#34;fam&#34;):
                    continue

                guardians = []

                # Get all family data except the names
                for guardian in data[:-1]:
                    # Avoid empty list
                    if guardian != &#34;&#34;:
                        self.stats[&#34;nber_guardian_wco&#34;] += 1
                        guardians.append(guardian)
                self.families[data[0]] = guardians
                category = &#34;fam&#34;
            else:
                # Handle students
                self.stats[&#34;nber_student_wco&#34;] += 1

                if self.code_is_empty(data, data_line_count):
                    continue

                if data[1] == &#34;&#34;:
                    # Skip if student gender is blank
                    self.notifications[&#34;errors&#34;][&#34;no_gender_students&#34;].append(
                        (self.base_url, data[2], data[-1],
                         self.cluster)
                    )
                    continue

                # Correct student code
                # Select a clean code from bank_code table with the appropriate values
                category = category_map[data[1].lower()]

            c_platform = school_caracteristics[0]
            self.cluster = school_caracteristics[6].lower()

            __year = str(datetime.date.today().year)[2:]
            acad_year = self.build_academic_year(self.cluster, category, __year)
            clean_code = &#34;&#34;

            self.db_manipulations(data[0], c_platform, category, acad_year)

    def code_replacer(self, datas, clean_id) -&gt; bool:
        result = False
        print(&#34;replace bad code on dashboard&#34;)
        try:
            selector = &#39;button[data-type = &#34;person&#34;]&#39;
            code_block = self.code_blocks[&#34;person&#34;]

            if type(datas) is str and not self.code_is_stored(datas, self._old_code):
                final_code = datas + &#34;;&#34; + clean_id
                self.stats[&#34;nber_student_wco_rpl&#34;] += 1
                if self.fill_code_for_replacement(final_code, code_block, selector):
                    self._old_code.append(datas)
            if type(datas) is list:
                i = 0
                is_filled = False
                for up_code in datas:
                    if not self.code_is_stored(up_code, self._old_code):
                        if i == 0:
                            final_code = up_code + &#34;;&#34; + clean_id
                            self.stats[&#34;nber_family_wco_rpl&#34;] += 1
                            if self.fill_code_for_replacement(final_code, self.code_blocks[&#34;user&#34;],
                                                              &#39;button[data-type = &#34;user&#34;]&#39;):
                                is_filled = True
                        else:
                            is_filled = False
                            final_code = up_code + &#34;;&#34; + clean_id + &#34;-&#34; + str(i)
                            self.stats[&#34;nber_guardian_wco_rpl&#34;] += 1
                            selector = &#39;button[data-type = &#34;person&#34;]&#39;
                            if self.fill_code_for_replacement(final_code, code_block, selector):
                                is_filled = True

                        if is_filled:
                            self._old_code.append(up_code)

                    i += 1
            result = True
            # print(&#34;Stats:&#34;, self.stats, &#34;errors:&#34;, self.notifications[&#34;errors&#34;])
        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        finally:
            return result

    def code_is_stored(self, code, o_codes) -&gt; bool:
        # Skip if code has been already replaced
        result = False
        if code in o_codes:
            print(f&#34;{code} has already been corrected&#34;)
            result = True

        return result

    def fill_code_for_replacement(self, data: str, block: webbrowser, selector: str):
        result = False
        try:
            block.clear()
            try:
                block.click()
            except ElementClickInterceptedException:
                time.sleep(3)
                block.click()

            block.send_keys(data)
            block.send_keys(Keys.ENTER)

            # &#39;button[data-type = &#34;person&#34;]&#39;  &#39;button[data-type = &#34;user&#34;]&#39;
            _code_btn = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            time.sleep(5)
            _code_btn.click()

            self.submit_updates()
            result = True
        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        finally:
            return result

    def submit_updates(self):
        time.sleep(5)
        while True:
            try:
                ui_dialog_buttonset = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
                    EC.presence_of_element_located((By.CLASS_NAME, &#39;ui-dialog-buttonset&#39;)))

                button = WebDriverWait(ui_dialog_buttonset, 15, ignored_exceptions=self.ignored_exceptions).until(
                    EC.presence_of_element_located((By.TAG_NAME, &#39;button&#39;)))

                button.click()
                break
            except ElementNotInteractableException:
                print(&#34;Waiting for element to be interectable...&#34;)

    def run(self, cmd: str) -&gt; None:
        # TODO: Handle mail notification for errors and statistics
        try:
            self.get_wrong_ids()
            self.code_categorizer()
            self.notifications[&#34;success&#34;] = {&#34;stats&#34;: self.stats, &#34;cluster&#34;: self.cluster, &#34;school&#34;: self.school}

            # Serialize notification for mailing
            f_name = &#34;mail&#34; + cmd + &#34;-&#34; + self.abbr
            f_name_path = os.path.join(self.autobackup_memoize, f_name)
            print(&#34;self notif &#34;, self.notifications)
            serialize(f_name_path, self.notifications)

        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        except EdukaNoJobExecution:
            self.error_logger.info(&#34;EdukaNoJobExecution occurred&#34;, exc_info=True)
        finally:
            self.browser.quit()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct"><code class="flex name class">
<span>class <span class="ident">Correct</span></span>
<span>(</span><span>school: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Define global scope project parameters and methods used in the whole project</p>
<p>The correct class browse Enko Dashboard in other to correct wrong student and family IDs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Correct(CodeManager):
    def __init__(self, school: str):
        &#34;&#34;&#34;
        The correct class browse Enko Dashboard in other to correct wrong student and family IDs
        &#34;&#34;&#34;
        super().__init__()
        self.browser = None
        self.school = school
        self.param = self.parameters
        self.cluster = &#34;&#34;
        self.mailer = EnkoMail(self.service_name, school)
        self.db_init()
        self.abbr = self.get_school_parameter(self.school, &#34;abbr&#34;)
        self.base_url = self.get_school_parameter(self.school, &#39;base_url&#39;)
        self.wrong_student_list_uri = self.base_url + self.get_school_parameter(self.school, &#39;wrong_student_list_uri&#39;)
        self.wrong_family_list_uri = self.base_url + self.get_school_parameter(self.school, &#39;wrong_family_list_uri&#39;)
        self.id_fname = &#34;idreplaced&#34; + self.abbr + &#34;.ep&#34;
        self.id_fname_path = os.path.join(self.autobackup_memoize, self.id_fname)

        self.columns_data: list = []
        self._old_code: list = []
        self.families = {}
        self.clean_datas = {}

        self.stats = {
            &#34;nber_student_wco&#34;: 0,
            &#34;nber_student_wco_rpl&#34;: 0,
            &#34;nber_family_wco&#34;: 0,
            &#34;nber_family_wco_rpl&#34;: 0,
            &#34;nber_guardian_wco&#34;: 0,
            &#34;nber_guardian_wco_rpl&#34;: 0
        }
        self.notifications = {
            &#34;errors&#34;: {
                &#34;students_blank_code&#34;: [],
                &#34;no_gender_students&#34;: [],
                &#34;no_clean_code_found&#34;: [],
                &#34;families_blank_code&#34;: []
            }
        }

        self.code_blocks = {&#34;person&#34;: None, &#34;user&#34;: None}

        self.no_code_available = []

        # Check Database components
        try:
            Populate(self.school).pre_check()
        except Exception:
            pass

    def code_is_empty(self, data: list, c_line, group=&#34;st&#34;) -&gt; bool:
        &#34;&#34;&#34;
        Check if code is empty
        @param data: list of student or family data
        @param c_line: family line number
        @param group: default is st for student.
        @return: a boolean value
        &#34;&#34;&#34;
        result = False
        strip_data = str(data[0]).strip(&#34; &#34;)

        if strip_data == &#34;&#34;:
            if group == &#34;st&#34;:
                # Student&#39;s code is blank
                self.notifications[&#34;errors&#34;][&#34;students_blank_code&#34;].append(
                    (self.base_url, data[2], data[-1], self.cluster)
                )
            else:
                if strip_data == &#34;&#34;:
                    self.notifications[&#34;errors&#34;][&#34;families_blank_code&#34;].append(
                        (self.wrong_family_list_uri, c_line, self.cluster)
                    )
            result = True

        return result

    def get_wrong_ids(self):

        urls = [
            self.wrong_student_list_uri,
            self.wrong_family_list_uri
        ]

        for url in urls:
            if url == &#34;&#34;:
                continue

            # Close the browser after the first id collection in other to avoid an isolated browser left running
            try:
                self.browser.quit()
            except AttributeError:
                pass

            self.browser = platform.login(
                url=url,
                logins=self.logins(self.school)
            )

            # Get printable link list as it content full data
            platform.goto_printable(self.browser)

            self.columns_data = platform.get_printable(self.browser)

        if self.columns_data.__len__() == 0:
            raise EdukaNoJobExecution(self.service_name, self.school, &#34;No Id to correct found&#34;)

        random.shuffle(self.columns_data)

        self.browser.get(
            self.base_url
            + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]
        )

    def db_manipulations(self, old_code, c_platform, category, acad_year):
        # Get the oldest student id
        query = f&#34;select code_id, code from bank_code where platform=&#39;{c_platform}&#39; and cluster=&#39;{self.cluster}&#39; and acad_year=&#39;{acad_year}&#39; and category=&#39;{category}&#39; and is_used=0 order by code_id asc&#34;

        with mysql.connector.connect(**self.db_config) as conn:
            global res
            cursor = conn.cursor(buffered=True)
            cursor.execute(&#39;use enko_db&#39;)
            cursor.execute(query)
            res = cursor.fetchone()

        if res is not None:
            clean_code_id = res[0]
            clean_code = res[1]

            # Update bank_code and replacement_logs tables
            # To insecure consistency, query is wrapped inside a transaction

            query2 = f&#34;INSERT INTO replacement_logs (old_code, new_code) VALUES (%s, %s);&#34;
            query3 = f&#34;UPDATE bank_code SET is_used=1,update_date=NOW() WHERE code=%s;&#34;

            with mysql.connector.connect(**self.db_config) as conn:
                try:
                    conn.autocommit = False
                    cursor = conn.cursor()
                    cursor.execute(&#39;use enko_db&#39;)
                    cursor.execute(query2, (old_code, clean_code_id))
                    cursor.execute(query3, (clean_code,))

                    try:
                        clean_datas = self.families[old_code]
                    except Exception:
                        clean_datas = old_code

                    # Handle replacement here. Make sure all went well before storing
                    if self.code_replacer(clean_datas, clean_code):
                        conn.commit()
                    else:
                        conn.rollback()
                        exit(&#34;Stop execution&#34;)

                    # print(f&#34;{clean_code_id} for {clean_code} Update&#34;)
                except (errors.InternalError, errors.ProgrammingError, errors.IntegrityError,
                        errors.InterfaceError):
                    self.error_logger.critical(&#34;DB error occurred&#34;, exc_info=True)
                    conn.rollback()
                except Exception as e:
                    conn.rollback()
                    self.error_logger.critical(&#34;Exception occurred&#34;, exc_info=True)
                    print(&#34;Exception&#34;, str(e))

        else:
            self.notifications[&#34;errors&#34;][&#34;no_clean_code_found&#34;].append(
                (c_platform, acad_year, category, self.cluster)
            )

        corrector_memoize = {
            &#34;code&#34;: self._old_code,
            &#34;stats&#34;: self.stats,
            &#34;notif&#34;: self.notifications
        }
        serialize(self.id_fname_path, corrector_memoize)

    def code_categorizer(self):
        school_caracteristics = &#34;&#34;
        category_map = {&#34;male&#34;: &#34;mst&#34;, &#34;female&#34;: &#34;fst&#34;, &#34;family&#34;: &#34;fam&#34;}
        data_inputs = self.get_good_codes_from_excel(self.parameters[&#34;global&#34;][&#34;eduka_code_manager_data_inputs&#34;])

        for data_input in data_inputs:
            if self.base_url == data_input[0] + &#34;/&#34;:
                school_caracteristics = data_input
                break

        if school_caracteristics == &#34;&#34;:
            # TODO: Handle this failure
            print(&#34;Couldn&#39;t find the school. Exit the program&#34;)

        self.browser.get(

            self.base_url
            + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]

        )
        platform.get_tabs(&#34;tabs&#34;, self.browser).find_elements(By.TAG_NAME, &#39;li&#39;)[4].click()

        data_line_count = 0

        user_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
            EC.presence_of_element_located((By.ID, &#39;UserCodeBox&#39;)))

        person_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
            EC.presence_of_element_located((By.ID, &#39;PersonCodeBox&#39;)))

        self.code_blocks[&#34;person&#34;] = person_code_box
        self.code_blocks[&#34;user&#34;] = user_code_box

        if os.path.exists(self.id_fname_path):
            deserial = deserialize(self.autobackup_memoize, self.id_fname)[0]
            self._old_code = [] if deserial[&#34;code&#34;] is None else deserial[&#34;code&#34;]
            self.stats[&#34;nber_family_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco&#34;]
            self.stats[&#34;nber_guardian_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco&#34;]
            self.stats[&#34;nber_student_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco&#34;]
            self.stats[&#34;nber_student_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco_rpl&#34;]
            self.stats[&#34;nber_family_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco_rpl&#34;]
            self.stats[&#34;nber_guardian_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco_rpl&#34;]
            self.notifications = deserial[&#34;notif&#34;]

        for data in self.columns_data[:1]:
            print(f&#34;Correct {data}...&#34;)

            data_line_count += 1
            if len(data) &gt; 4:
                # Handle family data
                if self.code_is_empty(data, data_line_count, &#34;fam&#34;):
                    continue

                guardians = []

                # Get all family data except the names
                for guardian in data[:-1]:
                    # Avoid empty list
                    if guardian != &#34;&#34;:
                        self.stats[&#34;nber_guardian_wco&#34;] += 1
                        guardians.append(guardian)
                self.families[data[0]] = guardians
                category = &#34;fam&#34;
            else:
                # Handle students
                self.stats[&#34;nber_student_wco&#34;] += 1

                if self.code_is_empty(data, data_line_count):
                    continue

                if data[1] == &#34;&#34;:
                    # Skip if student gender is blank
                    self.notifications[&#34;errors&#34;][&#34;no_gender_students&#34;].append(
                        (self.base_url, data[2], data[-1],
                         self.cluster)
                    )
                    continue

                # Correct student code
                # Select a clean code from bank_code table with the appropriate values
                category = category_map[data[1].lower()]

            c_platform = school_caracteristics[0]
            self.cluster = school_caracteristics[6].lower()

            __year = str(datetime.date.today().year)[2:]
            acad_year = self.build_academic_year(self.cluster, category, __year)
            clean_code = &#34;&#34;

            self.db_manipulations(data[0], c_platform, category, acad_year)

    def code_replacer(self, datas, clean_id) -&gt; bool:
        result = False
        print(&#34;replace bad code on dashboard&#34;)
        try:
            selector = &#39;button[data-type = &#34;person&#34;]&#39;
            code_block = self.code_blocks[&#34;person&#34;]

            if type(datas) is str and not self.code_is_stored(datas, self._old_code):
                final_code = datas + &#34;;&#34; + clean_id
                self.stats[&#34;nber_student_wco_rpl&#34;] += 1
                if self.fill_code_for_replacement(final_code, code_block, selector):
                    self._old_code.append(datas)
            if type(datas) is list:
                i = 0
                is_filled = False
                for up_code in datas:
                    if not self.code_is_stored(up_code, self._old_code):
                        if i == 0:
                            final_code = up_code + &#34;;&#34; + clean_id
                            self.stats[&#34;nber_family_wco_rpl&#34;] += 1
                            if self.fill_code_for_replacement(final_code, self.code_blocks[&#34;user&#34;],
                                                              &#39;button[data-type = &#34;user&#34;]&#39;):
                                is_filled = True
                        else:
                            is_filled = False
                            final_code = up_code + &#34;;&#34; + clean_id + &#34;-&#34; + str(i)
                            self.stats[&#34;nber_guardian_wco_rpl&#34;] += 1
                            selector = &#39;button[data-type = &#34;person&#34;]&#39;
                            if self.fill_code_for_replacement(final_code, code_block, selector):
                                is_filled = True

                        if is_filled:
                            self._old_code.append(up_code)

                    i += 1
            result = True
            # print(&#34;Stats:&#34;, self.stats, &#34;errors:&#34;, self.notifications[&#34;errors&#34;])
        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        finally:
            return result

    def code_is_stored(self, code, o_codes) -&gt; bool:
        # Skip if code has been already replaced
        result = False
        if code in o_codes:
            print(f&#34;{code} has already been corrected&#34;)
            result = True

        return result

    def fill_code_for_replacement(self, data: str, block: webbrowser, selector: str):
        result = False
        try:
            block.clear()
            try:
                block.click()
            except ElementClickInterceptedException:
                time.sleep(3)
                block.click()

            block.send_keys(data)
            block.send_keys(Keys.ENTER)

            # &#39;button[data-type = &#34;person&#34;]&#39;  &#39;button[data-type = &#34;user&#34;]&#39;
            _code_btn = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
            time.sleep(5)
            _code_btn.click()

            self.submit_updates()
            result = True
        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        finally:
            return result

    def submit_updates(self):
        time.sleep(5)
        while True:
            try:
                ui_dialog_buttonset = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
                    EC.presence_of_element_located((By.CLASS_NAME, &#39;ui-dialog-buttonset&#39;)))

                button = WebDriverWait(ui_dialog_buttonset, 15, ignored_exceptions=self.ignored_exceptions).until(
                    EC.presence_of_element_located((By.TAG_NAME, &#39;button&#39;)))

                button.click()
                break
            except ElementNotInteractableException:
                print(&#34;Waiting for element to be interectable...&#34;)

    def run(self, cmd: str) -&gt; None:
        # TODO: Handle mail notification for errors and statistics
        try:
            self.get_wrong_ids()
            self.code_categorizer()
            self.notifications[&#34;success&#34;] = {&#34;stats&#34;: self.stats, &#34;cluster&#34;: self.cluster, &#34;school&#34;: self.school}

            # Serialize notification for mailing
            f_name = &#34;mail&#34; + cmd + &#34;-&#34; + self.abbr
            f_name_path = os.path.join(self.autobackup_memoize, f_name)
            print(&#34;self notif &#34;, self.notifications)
            serialize(f_name_path, self.notifications)

        except Exception:
            self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
        except EdukaNoJobExecution:
            self.error_logger.info(&#34;EdukaNoJobExecution occurred&#34;, exc_info=True)
        finally:
            self.browser.quit()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>eduka_projects.services.code_manager.CodeManager</li>
<li>eduka_projects.services.ServiceManager</li>
<li>eduka_projects.bootstrap.Bootstrap</li>
<li>eduka_projects.EdukaProjects</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_categorizer"><code class="name flex">
<span>def <span class="ident">code_categorizer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_categorizer(self):
    school_caracteristics = &#34;&#34;
    category_map = {&#34;male&#34;: &#34;mst&#34;, &#34;female&#34;: &#34;fst&#34;, &#34;family&#34;: &#34;fam&#34;}
    data_inputs = self.get_good_codes_from_excel(self.parameters[&#34;global&#34;][&#34;eduka_code_manager_data_inputs&#34;])

    for data_input in data_inputs:
        if self.base_url == data_input[0] + &#34;/&#34;:
            school_caracteristics = data_input
            break

    if school_caracteristics == &#34;&#34;:
        # TODO: Handle this failure
        print(&#34;Couldn&#39;t find the school. Exit the program&#34;)

    self.browser.get(

        self.base_url
        + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]

    )
    platform.get_tabs(&#34;tabs&#34;, self.browser).find_elements(By.TAG_NAME, &#39;li&#39;)[4].click()

    data_line_count = 0

    user_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
        EC.presence_of_element_located((By.ID, &#39;UserCodeBox&#39;)))

    person_code_box = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
        EC.presence_of_element_located((By.ID, &#39;PersonCodeBox&#39;)))

    self.code_blocks[&#34;person&#34;] = person_code_box
    self.code_blocks[&#34;user&#34;] = user_code_box

    if os.path.exists(self.id_fname_path):
        deserial = deserialize(self.autobackup_memoize, self.id_fname)[0]
        self._old_code = [] if deserial[&#34;code&#34;] is None else deserial[&#34;code&#34;]
        self.stats[&#34;nber_family_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco&#34;]
        self.stats[&#34;nber_guardian_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco&#34;]
        self.stats[&#34;nber_student_wco&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco&#34;]
        self.stats[&#34;nber_student_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_student_wco_rpl&#34;]
        self.stats[&#34;nber_family_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_family_wco_rpl&#34;]
        self.stats[&#34;nber_guardian_wco_rpl&#34;] = deserial[&#34;stats&#34;][&#34;nber_guardian_wco_rpl&#34;]
        self.notifications = deserial[&#34;notif&#34;]

    for data in self.columns_data[:1]:
        print(f&#34;Correct {data}...&#34;)

        data_line_count += 1
        if len(data) &gt; 4:
            # Handle family data
            if self.code_is_empty(data, data_line_count, &#34;fam&#34;):
                continue

            guardians = []

            # Get all family data except the names
            for guardian in data[:-1]:
                # Avoid empty list
                if guardian != &#34;&#34;:
                    self.stats[&#34;nber_guardian_wco&#34;] += 1
                    guardians.append(guardian)
            self.families[data[0]] = guardians
            category = &#34;fam&#34;
        else:
            # Handle students
            self.stats[&#34;nber_student_wco&#34;] += 1

            if self.code_is_empty(data, data_line_count):
                continue

            if data[1] == &#34;&#34;:
                # Skip if student gender is blank
                self.notifications[&#34;errors&#34;][&#34;no_gender_students&#34;].append(
                    (self.base_url, data[2], data[-1],
                     self.cluster)
                )
                continue

            # Correct student code
            # Select a clean code from bank_code table with the appropriate values
            category = category_map[data[1].lower()]

        c_platform = school_caracteristics[0]
        self.cluster = school_caracteristics[6].lower()

        __year = str(datetime.date.today().year)[2:]
        acad_year = self.build_academic_year(self.cluster, category, __year)
        clean_code = &#34;&#34;

        self.db_manipulations(data[0], c_platform, category, acad_year)</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_empty"><code class="name flex">
<span>def <span class="ident">code_is_empty</span></span>(<span>self, data: list, c_line, group='st') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if code is empty
@param data: list of student or family data
@param c_line: family line number
@param group: default is st for student.
@return: a boolean value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_is_empty(self, data: list, c_line, group=&#34;st&#34;) -&gt; bool:
    &#34;&#34;&#34;
    Check if code is empty
    @param data: list of student or family data
    @param c_line: family line number
    @param group: default is st for student.
    @return: a boolean value
    &#34;&#34;&#34;
    result = False
    strip_data = str(data[0]).strip(&#34; &#34;)

    if strip_data == &#34;&#34;:
        if group == &#34;st&#34;:
            # Student&#39;s code is blank
            self.notifications[&#34;errors&#34;][&#34;students_blank_code&#34;].append(
                (self.base_url, data[2], data[-1], self.cluster)
            )
        else:
            if strip_data == &#34;&#34;:
                self.notifications[&#34;errors&#34;][&#34;families_blank_code&#34;].append(
                    (self.wrong_family_list_uri, c_line, self.cluster)
                )
        result = True

    return result</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_stored"><code class="name flex">
<span>def <span class="ident">code_is_stored</span></span>(<span>self, code, o_codes) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_is_stored(self, code, o_codes) -&gt; bool:
    # Skip if code has been already replaced
    result = False
    if code in o_codes:
        print(f&#34;{code} has already been corrected&#34;)
        result = True

    return result</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_replacer"><code class="name flex">
<span>def <span class="ident">code_replacer</span></span>(<span>self, datas, clean_id) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_replacer(self, datas, clean_id) -&gt; bool:
    result = False
    print(&#34;replace bad code on dashboard&#34;)
    try:
        selector = &#39;button[data-type = &#34;person&#34;]&#39;
        code_block = self.code_blocks[&#34;person&#34;]

        if type(datas) is str and not self.code_is_stored(datas, self._old_code):
            final_code = datas + &#34;;&#34; + clean_id
            self.stats[&#34;nber_student_wco_rpl&#34;] += 1
            if self.fill_code_for_replacement(final_code, code_block, selector):
                self._old_code.append(datas)
        if type(datas) is list:
            i = 0
            is_filled = False
            for up_code in datas:
                if not self.code_is_stored(up_code, self._old_code):
                    if i == 0:
                        final_code = up_code + &#34;;&#34; + clean_id
                        self.stats[&#34;nber_family_wco_rpl&#34;] += 1
                        if self.fill_code_for_replacement(final_code, self.code_blocks[&#34;user&#34;],
                                                          &#39;button[data-type = &#34;user&#34;]&#39;):
                            is_filled = True
                    else:
                        is_filled = False
                        final_code = up_code + &#34;;&#34; + clean_id + &#34;-&#34; + str(i)
                        self.stats[&#34;nber_guardian_wco_rpl&#34;] += 1
                        selector = &#39;button[data-type = &#34;person&#34;]&#39;
                        if self.fill_code_for_replacement(final_code, code_block, selector):
                            is_filled = True

                    if is_filled:
                        self._old_code.append(up_code)

                i += 1
        result = True
        # print(&#34;Stats:&#34;, self.stats, &#34;errors:&#34;, self.notifications[&#34;errors&#34;])
    except Exception:
        self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
    finally:
        return result</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.db_manipulations"><code class="name flex">
<span>def <span class="ident">db_manipulations</span></span>(<span>self, old_code, c_platform, category, acad_year)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def db_manipulations(self, old_code, c_platform, category, acad_year):
    # Get the oldest student id
    query = f&#34;select code_id, code from bank_code where platform=&#39;{c_platform}&#39; and cluster=&#39;{self.cluster}&#39; and acad_year=&#39;{acad_year}&#39; and category=&#39;{category}&#39; and is_used=0 order by code_id asc&#34;

    with mysql.connector.connect(**self.db_config) as conn:
        global res
        cursor = conn.cursor(buffered=True)
        cursor.execute(&#39;use enko_db&#39;)
        cursor.execute(query)
        res = cursor.fetchone()

    if res is not None:
        clean_code_id = res[0]
        clean_code = res[1]

        # Update bank_code and replacement_logs tables
        # To insecure consistency, query is wrapped inside a transaction

        query2 = f&#34;INSERT INTO replacement_logs (old_code, new_code) VALUES (%s, %s);&#34;
        query3 = f&#34;UPDATE bank_code SET is_used=1,update_date=NOW() WHERE code=%s;&#34;

        with mysql.connector.connect(**self.db_config) as conn:
            try:
                conn.autocommit = False
                cursor = conn.cursor()
                cursor.execute(&#39;use enko_db&#39;)
                cursor.execute(query2, (old_code, clean_code_id))
                cursor.execute(query3, (clean_code,))

                try:
                    clean_datas = self.families[old_code]
                except Exception:
                    clean_datas = old_code

                # Handle replacement here. Make sure all went well before storing
                if self.code_replacer(clean_datas, clean_code):
                    conn.commit()
                else:
                    conn.rollback()
                    exit(&#34;Stop execution&#34;)

                # print(f&#34;{clean_code_id} for {clean_code} Update&#34;)
            except (errors.InternalError, errors.ProgrammingError, errors.IntegrityError,
                    errors.InterfaceError):
                self.error_logger.critical(&#34;DB error occurred&#34;, exc_info=True)
                conn.rollback()
            except Exception as e:
                conn.rollback()
                self.error_logger.critical(&#34;Exception occurred&#34;, exc_info=True)
                print(&#34;Exception&#34;, str(e))

    else:
        self.notifications[&#34;errors&#34;][&#34;no_clean_code_found&#34;].append(
            (c_platform, acad_year, category, self.cluster)
        )

    corrector_memoize = {
        &#34;code&#34;: self._old_code,
        &#34;stats&#34;: self.stats,
        &#34;notif&#34;: self.notifications
    }
    serialize(self.id_fname_path, corrector_memoize)</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.fill_code_for_replacement"><code class="name flex">
<span>def <span class="ident">fill_code_for_replacement</span></span>(<span>self, data: str, block: <module 'webbrowser' from 'C:\\Python311\\Lib\\webbrowser.py'>, selector: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_code_for_replacement(self, data: str, block: webbrowser, selector: str):
    result = False
    try:
        block.clear()
        try:
            block.click()
        except ElementClickInterceptedException:
            time.sleep(3)
            block.click()

        block.send_keys(data)
        block.send_keys(Keys.ENTER)

        # &#39;button[data-type = &#34;person&#34;]&#39;  &#39;button[data-type = &#34;user&#34;]&#39;
        _code_btn = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
        time.sleep(5)
        _code_btn.click()

        self.submit_updates()
        result = True
    except Exception:
        self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
    finally:
        return result</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.get_wrong_ids"><code class="name flex">
<span>def <span class="ident">get_wrong_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wrong_ids(self):

    urls = [
        self.wrong_student_list_uri,
        self.wrong_family_list_uri
    ]

    for url in urls:
        if url == &#34;&#34;:
            continue

        # Close the browser after the first id collection in other to avoid an isolated browser left running
        try:
            self.browser.quit()
        except AttributeError:
            pass

        self.browser = platform.login(
            url=url,
            logins=self.logins(self.school)
        )

        # Get printable link list as it content full data
        platform.goto_printable(self.browser)

        self.columns_data = platform.get_printable(self.browser)

    if self.columns_data.__len__() == 0:
        raise EdukaNoJobExecution(self.service_name, self.school, &#34;No Id to correct found&#34;)

    random.shuffle(self.columns_data)

    self.browser.get(
        self.base_url
        + self.param[&#39;enko_education&#39;][&#39;replacer_uri&#39;]
    )</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, cmd: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, cmd: str) -&gt; None:
    # TODO: Handle mail notification for errors and statistics
    try:
        self.get_wrong_ids()
        self.code_categorizer()
        self.notifications[&#34;success&#34;] = {&#34;stats&#34;: self.stats, &#34;cluster&#34;: self.cluster, &#34;school&#34;: self.school}

        # Serialize notification for mailing
        f_name = &#34;mail&#34; + cmd + &#34;-&#34; + self.abbr
        f_name_path = os.path.join(self.autobackup_memoize, f_name)
        print(&#34;self notif &#34;, self.notifications)
        serialize(f_name_path, self.notifications)

    except Exception:
        self.error_logger.critical(&#34;ConnectionError occurred&#34;, exc_info=True)
    except EdukaNoJobExecution:
        self.error_logger.info(&#34;EdukaNoJobExecution occurred&#34;, exc_info=True)
    finally:
        self.browser.quit()</code></pre>
</details>
</dd>
<dt id="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.submit_updates"><code class="name flex">
<span>def <span class="ident">submit_updates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit_updates(self):
    time.sleep(5)
    while True:
        try:
            ui_dialog_buttonset = WebDriverWait(self.browser, 15, ignored_exceptions=self.ignored_exceptions).until(
                EC.presence_of_element_located((By.CLASS_NAME, &#39;ui-dialog-buttonset&#39;)))

            button = WebDriverWait(ui_dialog_buttonset, 15, ignored_exceptions=self.ignored_exceptions).until(
                EC.presence_of_element_located((By.TAG_NAME, &#39;button&#39;)))

            button.click()
            break
        except ElementNotInteractableException:
            print(&#34;Waiting for element to be interectable...&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager" href="index.html">eduka-projects.eduka_projects.services.code_manager</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct">Correct</a></code></h4>
<ul class="">
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_categorizer" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_categorizer">code_categorizer</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_empty" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_empty">code_is_empty</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_stored" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_is_stored">code_is_stored</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_replacer" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.code_replacer">code_replacer</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.db_manipulations" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.db_manipulations">db_manipulations</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.fill_code_for_replacement" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.fill_code_for_replacement">fill_code_for_replacement</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.get_wrong_ids" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.get_wrong_ids">get_wrong_ids</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.run" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.run">run</a></code></li>
<li><code><a title="eduka-projects.eduka_projects.services.code_manager.corrector.Correct.submit_updates" href="#eduka-projects.eduka_projects.services.code_manager.corrector.Correct.submit_updates">submit_updates</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>